using cdcrush.lib;
using cdcrush.lib.app;
using cdcrush.lib.task;

using System;
using System.IO;


namespace cdcrush.prog
{
	
	
// Every Crush Job runs with these input parameters
public struct CrushParams
{	
	public string inputFile;	// The CUE file to compress
	public string outputDir;	// Output Directory.
	public string cdTitle;		// Custom CD TITLE
	public Tuple<int,int> audioQuality;	// Tuple<AudioCodecID, Bitrate/Index> !!
	public string cover;			// Cover image for the CD, square
	public int compressionLevel;	// Describe the compression level, 0-10?
	public int expectedTracks;		// In order for the progress report to work. set num of CD tracks here.
	
	// : Internal Access : ----

	// Keep the CD infos of the CD, it is going to be read later
	public cd.CDInfos cd {get; internal set;}
	// Filesize of the final archive
	public int crushedSize {get; internal set;}
	// Temp dir for the current batch, it's autoset, is a subfolder of the master TEMP folder.
	internal string tempDir;
	// Final destination ARC file, autogenerated from CD TITLE
	internal string finalArcPath;
	// If true, then all the track files are stored in temp folder and safe to delete
	internal bool flag_sourceTracksOnTemp;
	// USED in `JobConvertCue`
	internal bool flag_convert_only;

}// --


/// <summary>
/// A collection of tasks, that will CRUSH a cd,
/// Tasks will run in order, and some will run in parallel
/// </summary>
class JobCrush:CJob
{
	// --
	public JobCrush(CrushParams p):base("Compress CD")
	{
		// Check for input files
		// :: --------------------
			if(!CDCRUSH.check_file_(p.inputFile,".cue")) {
				fail(msg:CDCRUSH.ERROR);
				return;
			}

			if(string.IsNullOrEmpty(p.outputDir)) {
				p.outputDir = Path.GetDirectoryName(p.inputFile);
			}

			if(!FileTools.createDirectory(p.outputDir)) {
				fail(msg: "Can't create Output Dir " + p.outputDir);
				return;
			}

			p.tempDir = CDCRUSH.getSubTempDir();
			if(!FileTools.createDirectory(p.tempDir)) {
				fail(msg: "Can't create TEMP dir");
				return;
			}

		// -
		p.flag_convert_only = false;

		// IMPORTANT!! sharedData gets set by value, NOT A POINTER, do not make changes to p after this
		jobData = p;

		// 
		hack_setExpectedProgTracks(p.expectedTracks + 3);

		// --
		// - Read the CUE file ::
		add(new CTask((t) =>
		{
			var cd = new cd.CDInfos();

			jobData.cd = cd;

			try{
				cd.cueLoad(p.inputFile);
			}catch(haxe.lang.HaxeException e) {
				t.fail(msg:e.Message); return;
			}

			// Meaning the tracks are going to be extracted in the temp folder
			jobData.flag_sourceTracksOnTemp = (!cd.MULTIFILE && cd.tracks.length > 1);

			// In case user named the CD, otherwise it's going to be the same
			if(!string.IsNullOrWhiteSpace(p.cdTitle))
			{
				cd.CD_TITLE = FileTools.sanitizeFilename(p.cdTitle);
			}

			// Real quality to string name
			cd.CD_AUDIO_QUALITY = CDCRUSH.getAudioQualityString(p.audioQuality);

			// Generate the final arc name now that I have the CD TITLE
			jobData.finalArcPath = Path.Combine(p.outputDir, cd.CD_TITLE + CDCRUSH.CDCRUSH_EXTENSION);

			// Try to create a new archive in case it exists?
			while(File.Exists(jobData.finalArcPath))
			{
				LOG.log("{0} already exists, adding (_) until unique", jobData.finalArcPath);
				String S = jobData.finalArcPath;
				jobData.finalArcPath = S.Substring(S.Length-4) + "_" + CDCRUSH.CDCRUSH_EXTENSION;
			}

			LOG.log("- Destination Archive : {0}", jobData.finalArcPath);

			t.complete();

		}, "-Reading", "Reading CUE data and preparing"));
		
		// - Cut tracks
		// ---------------------------
		add(new TaskCutTrackFiles());

		// - Compress tracks
		// ---------------------
		add(new CTask((t) =>
		{
			cd.CDInfos CD = jobData.cd;
			//foreach(cd.CDInfos tr in CD.tracks) {
			for(var i=0;i<CD.tracks.length;i++) {
				addNextAsync(new TaskCompressTrack(CD.tracks[i] as cd.CDTrack));
			}//--
			t.complete();
		}, "-Preparing","Preparing to compress tracks"));


		// Create Archive
		// Add all tracks to the final archive
		// ---------------------
		add(new CTask((t) => 
		{
			cd.CDInfos CD = jobData.cd;
		
			// -- Get list of files::
			System.Collections.ArrayList files = new System.Collections.ArrayList();
			for(var i=0;i<CD.tracks.length;i++) {
				files.Add((CD.tracks[i] as cd.CDTrack).workingFile); // Working file is valid, was set earlier
			}

			// Compress all the track files
			var arc = new FreeArc(CDCRUSH.TOOLS_PATH);
			t.handleCliReport(arc);
			arc.compress((string[])files.ToArray(typeof(string)), jobData.finalArcPath, p.compressionLevel);
			arc.onProgress = (pr) => t.PROGRESS = pr;
			t.killExtra = () => arc.kill();

		}, "Compressing", "Compressing everything into an archive"));


		// - Create CD SETTINGS and push it to the final archive
		// ( I am appending these files so that they can be quickly loaded later )
		// --------------------
		add(new CTask((t) =>
		{
			cd.CDInfos CD = jobData.cd;
			
			LOG.log("== Detailed CD INFOS ==");
			LOG.log(CD.getDetailedInfo());

			string path_settings = Path.Combine(p.tempDir, CDCRUSH.CDCRUSH_SETTINGS);
			try{
				CD.jsonSave(path_settings);
			}catch(haxe.lang.HaxeException e){
				t.fail(msg:e.Message); return;
			}
	
			// - Cover Image Set?
			string path_cover;
			if(p.cover!=null) {
				path_cover = Path.Combine(p.tempDir,CDCRUSH.CDCRUSH_COVER);
				File.Copy(p.cover,path_cover);
			}else {
				path_cover = null;
			}

			// - Append the file(s)
			var arc = new FreeArc(CDCRUSH.TOOLS_PATH);
			t.handleCliReport(arc);
			arc.appendFiles(new string[]{path_settings, path_cover},jobData.finalArcPath);

			t.killExtra = () => arc.kill();

		}, "Finalizing", "Appending cover and settings into the archive"));

		// - Get post data
		add(new CTask((t) =>
		{
			var finfo = new FileInfo(jobData.finalArcPath);
			jobData.crushedSize = (int)finfo.Length;
			t.complete();

		}, "-Finalizing"));

		// -- COMPLETE --

	}// -----------------------------------------

	// -
	public override void start()
	{
		CrushParams p = jobData;
		LOG.line();
		LOG.log("= COMPRESSING A CD with the following parameters :");
		LOG.log("- Input : {0}", p.inputFile);
		LOG.log("- Output Dir : {0}", p.outputDir);
		LOG.log("- Temp Dir : {0}", p.tempDir);
		LOG.log("- CD Title  : {0}", p.cdTitle);
		LOG.log("- Audio Quality : {0}",CDCRUSH.getAudioQualityString(p.audioQuality));
		LOG.log("- Compression Level : {0}", p.compressionLevel);
		LOG.log("- Cover Image : {0}",p.cover);
		base.start();
	}// -----------------------------------------

	/// <summary>
	/// Called on FAIL / COMPLETE / PROGRAM EXIT
	/// Clean up temporary files
	/// </summary>
	protected override void kill()
	{
		base.kill();

		if(CDCRUSH.FLAG_KEEP_TEMP) return;

		// - Cleanup
		CrushParams p = jobData;
		if (p.tempDir != p.outputDir)  // NOTE: This is always a subdir of the master temp dir
		{ 
			try {
				Directory.Delete(p.tempDir, true);
			} catch(IOException) {
				// do nothing
			}
		}// --	
	}// -----------------------------------------

}// --
}// --
